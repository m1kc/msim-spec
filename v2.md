# mSIM spec

## Транспортный протокол

В качестве транспортного уровня могут использоваться различные фасады. Далее описаны два из них для примера.

### TCP

Применяется бинарный формат с 4 обязательными полями:
* `uint32` sequence_number - маркер пакета для идентификации ответа
* `string (Pascal style: uint8 length, then bytes)` type - тип пакета
* `uint64` length - длина тела пакета
* `uint16` status - статус ответа
* `bytes` body - тело запроса

### HTTP

Применяется текстовый формат HTTP/1.1 с минимальным набором обязательных полей. Никакие поля, кроме статуса, Content-Length и типа пакета, не являются значимыми и могут игнорироваться парсером.

Запрос обновлений:

```
GET /fetch HTTP/1.1
Host: msim.im
Content-Length: 0
Connection: keep-alive

HTTP/1.1 200 OK
Content-Length: <length>
X-Type: MESSAGE-RECEIVE

<body>
```

Транзакционный запрос:
```
POST /<type> HTTP/1.1
Host: msim.im
Content-Length: <length>
Connection: keep-alive

HTTP/1.1 200 OK
Content-Length: <length>
X-Type: <type, optional>

<body>
```

## Формат тела пакетов

TBD

## Статусы

* `200` - запрос прошёл успешно
* `400` - запрос сформирован неверно
* `401` - требуется авторизация
* `500` - сервер отдыхает
* `501` - не реализовано

Остальные ошибки - в соответствующих разделах.

## Базовые возможности

Вместо пароля клиент использует пару ключей, полученную через PBKDF2(HMAC−SHA1, пароль, 0x00000000, 4096, 256).

### Регистрация

```
<< REGISTER login=Vasya publickey=540345095834ncv095==
>> 200
>> 403 reason=why
```

### Подключение

Клиент: привет, я Вася  
Сервер: привет, вот тебе случайная строка и монотонно возрастающее число, подпиши это своим приватным ключом
Клиент: вот  
Сервер: ок

```
<< CONNECT login=Vasya
>> 200 challenge=987243897h9h4c3dx2 seq=63742231879
// Всегда 200, даже если такого юзера нет
// Клиент подписывает (challenge | seq | salt) своим приватным ключом, где salt - случайная строка
<< CONNECT-CONTINUE signed=7878fd798fd7fdaha79ah7==
>> 200
>> 403
```

### Получение списка контактов

```
<< CONTACTS-GET
>> 200
    [
    ...id=m1kc@klfd.com
    ...name=m1kc
    ...note=Something optional
    ...last-seen=2018-09-09T14:22:31+0300
    ]
// Теоретически сервер должен всегда это
успешно выполнять. Ну или дисконнект делать,
если уж совсем припёрло.
```

Вроде больше ничего не надо внутри. Сейчас подумаю. Тут бы, конечно, хорошо передавать last-seen. А, опционально можно.
Кстати, сам last-seen можно вообще сделать как модификацию контакта. Что пришло, то в клиенте и обновилось. Хм, надо подумать

### Сообщения

```
<< MESSAGE-SEND to=m1kc@whatever.com text=HJDJKFDSJKsjfjoifuwhiufe
>> 200 id=789387923
>> 400
...
>> MESSAGE-READ id=[789387923, ...]
```

```
>> MESSAGE-RECEIVE id=789387923 from=m1kc@whatever.com text=HJDJKFDSJKsjfjoifuwhiufe
<< MESSAGE-RECEIVE-ACK id=[789387923, ...]
>> 200
```

Для подтверждения о получении сообщения отправляется массив `id` сообщений.

## Основные возможности

### Сообщения с аттачем

Под `blob` подразумевается бинарный контент, приложенный к сообщению. Это может быть стикер, небольшой файл изображения или крошечный документ. Ограничение может быть предусмотрено в несколько килобайт. В любом случае, сервер должен обрывать запросы больше определённого размера, пакет сообщения не исключение.
```
<< MESSAGE to=m1kc@whatever.com text=HJDJKFDSJKsjfjoifuwhiufe blob=<data>
>> 200 id=789387923
>> 400
```

Либо можно сделать отдельный тип сообщений blob, вроде так почётче. Тоже думал над таким форматом. Можно и так сделать.
```
<< MESSAGE to=m1kc@whatever.com type=text text=<data>
<< MESSAGE to=m1kc@whatever.com type=blob blob=<data>
```

### Уведомление о наборе текста

```
>> TYPING-STARTED from=solkin@whatever.com
>> TYPING-END from=solkin@whatever.com
```

### Presence

```
>> UPDATE-LAST-SEEN id=Vasya at=2018-09-09T14:22:31+0300
```

## Управление контактами

### add/change/delete

```
<< CONTACTS-ADD name=m1kc id=m1kc@m1kc.ru
>> 200
>> 400 reason=why

<< CONTACTS-CHANGE id=m1kc@m1kc.ru name=MIKUSO
>> 200
>> 400 reason=why

<< CONTACTS-DELETE id=m1kc@m1kc.ru
>> 200
>> 400 reason=why
```

### Контакт изменился на сервере

...Может, вообще весь список заново отправлять... Накладно будет. Зато действительно можно присылать то, что поменялось и упростить работу last-seen. Интересно. Но пока не могу понять, нравится мне такой подход или нет. Клиенту надо будет ещё проверять, поменялось ли имя (и надо ли теперь лезть в sqlite и обновлять его). Обработчик этого пакета станет слишком умным. М-м...
По опыту Мандарина могу сказать, что last-seen и изменение списка всё равно сводилось к одной операции. Может, это только у тебя так? Я пытаюсь представить себе это - наверное, всё-таки это были бы разные вещи, если я реально храню историю с привязкой к контактам и их имена тоже храню.
Так ведь клиенту и так и так надо обновить одну и ту же сущность - контакт. И не важно, какое поле у него поменялось, имя и время. Клиент получается максимально тонким.
Но ведь last-seen он обычно хранится в памяти, а имя в каком-нибудь sqlite. Разница. Нет. Всё хранися рядом в одной записи базы. А зачем ты хранишь в базе last seen? И блин, это ж всё время в базу лазить.
Поход в базу дешёвый. Это одно. Но главное, что клиент ты можешь убить 100 раз в минуту и клиенту не нужно постоянно идти на сервер и актуализировать информацию по контактам.
А, блин, да, это ж андроид. Понял, почему. Но на десктопах не так делают.
iOS то же самое. На десктопе можно делать как угодно, сути это всё равно не меняет. Или, например, взять тот же Web. Там вообще ничего хранить не надо, но сущность обновляется без задней мысли. Контакт поменялся? Обновляем.
Ладно, оставим пока оба типа, потом выкинем отдельный, если не передумаем. Ок см. дальше

```
>> CONTACT-UPDATED
    [
    ...id=m1kc@klfd.com
    ...name=m1kc
    ...last-seen=2018-09-09T14:22:31+0300
    ]
```
```
>> CONTACT-UPDATED
    [
    ...id=m1kc@klfd.com
    ...last-seen=2018-09-09T14:22:31+0300
    ]
```
```
>> CONTACT-UPDATED
    [
    ...id=m1kc@klfd.com
    ...note=Vacationing
    ]
```
```
>> CONTACT-UPDATED
    [
    ...id=m1kc@klfd.com
    ...name=m1kc
    ]
```


...Так. А что, если просто добавить поле group в контакт? Хочешь удалить группу - ну удали все контакты в ней.
Так как раз в XMPP сделано. Бодрое решение. Но, вероятно, группы вообще должны быть опциональны. Типа, не хочешь указывать группу - не надо. Это правильно. Ещё можно сделать вложенные группы для самых упоротых, типа `group1.group2` и на самом деле group2 вложена в group1. Можно и так. Это уже на уровень клиента выходит тогда. Можно через `/` ещё.

Кстати, можно сделать некую сущность `note` у контакта. Для тех случаев, когда контакту нужна пометка. Типа текстового статуса. Полезно бывает, например, в корпоротивном использовании, когда уходишь в отпуск. Согласен

### Профили

TBD

А давай её прям одним из полей контакта сделаем?
Имеешь в виду профиля?

`CONTACTS-UPDATE id=m1kc@m1kc.ru name=m1kc note=Whatever Vacation`
А, так я имел в виду, что пользователь сам заполняет себе заметку. 
А, профили... О них я не думал. Они нужны?
По хорошему, было бы неплохо иметь имя контакта, чтобы каждому его не задавать вручную. При желании, конечно, можно изменить.
Ладно, добавим потом. Но это явно не для MVP, как мне кажется.
Может быть. А так, `note` конечно является полем контакта в списке, как и `last-seen`. Тоже заполяется не самим владельцем списка контактов. В общем, его можно потом.
```
<< PROFILE-UPDATE name=Superuser
>> PROFILE-UPDATE-FAILED reason=why
>> PROFILE-UPDATE-OK
```
```
<< PROFILE-UPDATE name=Megauser, note=Vacationing
>> PROFILE-UPDATE-FAILED reason=why
>> PROFILE-UPDATE-OK
```


### Отправка файлов

Всё же я бы сделал возможность кратковременного хранения файлов на сервере. Либо даже только такой способ и только для мелких файлов. Для начала можно вообще только изображения рассмотреть.
```
Вася:
<< SEND-FILE-PROXY filename=virus.exe size=128000
>> 200

Сервер - Пете:
>> SEND-FILE-PROXY-REQUEST filename=virus.exe size=128000 transfer-id=123
<< SEND-FILE-PROXY-ACCEPT transfer-id=123
<< SEND-FILE-PROXY-REJECT transfer-id=123

Сервер - Васе:
>> SEND-FILE-PROXY-OK connect=filetransfer.com port=5555 transfer-id=123
>> SEND-FILE-PROXY-REJECTED transfer-id=123
```

Протокол передачи файлов на прокси:

TBD

Далее клиент подключается на другой порт 3215 и передаёт файл в аналогичном виде:

## Федерация

TBD

Серверу нужно, наверное, иметь возможность запретить внешние взаимодействия? Хотя при этом получается рак-отшельник, который ни с кем другим не общается.

Конечно. В этом случае он просто отвечает, что федерация not implemented.

Конечно, неплохо бы об этом ещё заранее как-то сообщить, типа как капсы при подключении слать. Ну или просто federated=false.
Думаю, проще всего реально через `not supported` И там уже не нужно гадать, почему он не поддерживает. Просто не поддерживает.
Ну можно совместить: при подключении предупреждать, а при попытке, например, добавить контакт с другого сервера - фейлить. А если сервер контакта не поддерживает федерацию? Тогда... я думаю, на первом этапе можно вообще не проверять контакты на других серверах и позволять добавлять любые. Потом сделать какой-то специальный пакет, чтобы спросить, есть такая учётка или нет.
При изменении информации у пользователя надо будет проходить по списку и слать изменения не только себе на сервер, но если контакт внешний, отправлять запросы другому серверу через федерацию.
Предлагаю это делать сильно позже. 
Я думаю, обновления ни профилей, ни last seen по умолчанию на другие сервера слать не нужно. Потом сделаем какой-то механизм подписки на обновления. Если попросили - шлю.
По идее, должно быть единообразно с сообщениями. А описанный мехнизм ниже должен лежать в транспортном уровне. Типа, хочу отправить пакет твоему клиенту. Подключаюсь, проходит хэндшейк и пакет уходит.

Сервер подключается к другому серверу  
Говорит: я solkin.ru, хочу подключиться к m1kc.ru  
Если я m1kc.ru, то говорю: вот тебе challenge  
Ты подписываешь challenge своим закрытым ключом  
Я получаю твой открытый ключ из DNS-записи и убеждаюсь, что ты и правда solkin.ru
Далее происходит отправка пакета, аналогично отправке пакета локальному пользователю. Сторонний сервер проксирует данные без дополнительной обработки. Либо проверяет исключительно с целью соответствия, хотя это уже из области безопасности. Ну да. Наверное, просто добавим в пакет поле from, которое разрешено заполнять только серверам. И оно как раз на этапе хэндшейка будет выступать как необходимая информация. Можно так.
