# mSIM 2.0

mSIM - легковесный протокол обмена мгновенными сообщениями. Первая версия появилась в 2012 году как протест против перегруженных, сложных в реализации протоколов OSCAR и XMPP; тогда же были написаны референсные реализации msimd и OpenIM. Это вторая версия, написанная в 2019 году; протокол значительно расширен и дополнен с учётом опыта других протоколов и ожиданий пользователей. При этом mSIM всё ещё лёгок в реализации, может применяться на устройствах с малой вычислительной мощностью, его сервера могут быстро работать даже на RPi, он обеспечивает уровень пользовательского комфорта на уровне конкурирующих протоколов и прост для понимания - полная спецификация занимает всего несколько страниц. Референсные реализации mSIM 2.0 в процессе написания.

mSIM работает поверх TLS, может использовать HTTP, TCP или другой транспорт. Допускается мультиплексирование нескольких сессий через одно соединение. Формат пакетов - JSON. Возможности протокола разделены на слои: с их помощью легко обеспечивается поддержка старых клиентов.

Помимо стандартных для 2019 года возможностей протокол предусматривает федерацию, групповые чаты, отправку больших файлов.

История переписки хранится на сервере, но клиент не обязан делать полную синхронизацию и может использовать только приём/отправку. Набор отправляемых заголовков HTTP ограничен для возможности использовать упрощённые парсеры.

## Транспорт

### Шифрование опционально

В данный момент предусмотрены два транспорта: TCP+TLS и HTTP+TLS (HTTPS). Сервер может быть настроен на использование этих же протоколов, но без шифрования. Настройка глобальна: сервер ДОЛЖЕН либо использовать шифрование для всех клиентов, либо не использовать тоже для всех. Клиенту СЛЕДУЕТ предупреждать пользователя об опасности при добавлении нешифрованного сервера.

Допускается (но пока не определено) использование других протоколов, кроме TLS.

При проверке сертификата клиенту СЛЕДУЕТ использовать одну из следующих стратегий:

* Использование доверенного хранилища корневых сертификатов;
* Закрепление корневого сертификата;
* Закрепление конкретного сертификата.

### Схемы

`msim-tcp://user@server:port`
`msim-tcp://user:plaintext_password@server:port`
`msim-http://user@server:port/[api_url]`
`msim-http://user@server:port/[api_url]?root-cert=7894fjd...skfdsj==`
`msim-http://user@server:port/[api_url]?end-cert=7894fjd...skfdsj==`
`msim-http-insecure://user@server:port/[api_url]`


### Пакет

Пакеты mSIM могут передаваться при помощи разных транспортных протоколов. В любом из них пакет включает следующие поля:

* `uint32` Номер слоя
* `32 байта` ID сессии
* `string` Тип пакета
* `uint16` Статус ответа (0 для пакетов, отправленных клиентом)
* `bytes` Тело сообщения

В качестве транспортного уровня могут использоваться различные фасады. Далее описаны два из них для примера.

При ошибках разбора пакетов клиент (или сервер) ДОЛЖЕН разрывать соединение и как-то информировать пользователя о проблеме на той стороне.

### Транспорт TCP

Применяется бинарный формат с 4 обязательными полями:
* `uint32` Номер слоя
* `32 байта` ID сессии (или 0x00, если нет)
* `uint32` sequence_number - маркер пакета для идентификации ответа
* `string (Pascal style: uint8 length, then bytes)` type - тип пакета
* `uint64` length - длина тела пакета
* `uint16` status - статус ответа
* `bytes` body - тело запроса

### Транспорт HTTP

> Разрешено ли иметь несколько серверов с разными hostname на одном порту? HTTP это разрешает, TCP - не очень. Моё мнение - от запрета никто особо не пострадает, а поддерживать эту странную конфигурацию я не хочу

Применяется формат HTTP с минимальным набором обязательных заголовков. Никакие заголовки, кроме статуса, Content-Length, Connection и типа пакета, не являются значимыми, и парсер ДОЛЖЕН их игнорировать (но их могут читать промежуточные прокси-сервера). Заголовок Host обязателен в HTTP/1.1, но парсер mSIM также ДОЛЖЕН его игнорировать (однако его может читать реверс-прокси). Допускается использование любых версий HTTP, если их семантика совместима с HTTP/1.0.

Номер слоя передаётся в URL (например, `/v1/`).

Кодировка запросов и ответов - всегда UTF-8. При этом клиенту и серверу СЛЕДУЕТ проверять поле Content-Type, если оно присутствует, и выводить предупреждение, если в нём указана иная кодировка.

Запрос обновлений:

```
GET /v<layer>/fetch HTTP/1.1
Host: msim.im
Connection: keep-alive
[X-Session: <hex string>]

HTTP/1.1 200 OK
Content-Length: <length>
X-Type: MESSAGE-RECEIVE

<body>
```

Транзакционный запрос:

```
POST /v<layer>/<type> HTTP/1.1
Host: msim.im
Content-Length: <length>
Connection: keep-alive
[X-Session: <hex string>]

<body>


HTTP/1.1 200 OK
Content-Length: <length>
[X-Type: <type>]

<body>
```

## Формат тела пакетов

JSON object.

Тело ответа не может быть массивом, массивы могут быть внутри.

Ответы ДОЛЖНЫ содержать все обязательные поля, если нет - клиенту СЛЕДУЕТ игнорировать такие пакеты и как-то сообщать пользователю о проблеме на той стороне, серверу СЛЕДУЕТ отвечать кодом 400.

## Статусы

* `200` - запрос прошёл успешно
* `400` - запрос сформирован неверно
* `401` - требуется авторизация
* `500` - сервер отдыхает
* `501` - не реализовано

Остальные ошибки - в соответствующих разделах.

## Гарантии стабильности

Слои с пометкой `EXPERIMENTAL` могут измениться в будущем. Остальные - только в случае обнаружения каких-то серьёзных проблем.

## Типы пакетов

> Короче, в чём суть. Поддержка протокола версии X просто означает, что клиент может говорить на этой версии протокола, то есть он способен распарсить пакеты и выдать в ответ что-то адекватное. Если поддерживаемая версия меньше X, то сервер точно знает, что клиент старый и возможности X+1 и выше поддерживать не может. Если поддерживаемая версия выше или равна - сервер не делает никаких предположений, поддерживаются ли реально клиентом новые возможности - это не его собачье дело, но слать новые пакеты уже может.
>
> А плюсов много. Если в каком-то протоколе N капсов, то сервер и клиент по сути должны поддерживать (N факториал) похожих, но разных версий протокола. И слава богу, если они просто отличаются наличием каких-то фич. Через капсы невозможно внести security fix в какую-то существующую фичу, удалить её совсем или заменить на улучшенную. Через модель со слоями - можно.

> Игорь Солкин, [26.06.19 16:15]
> Кстати, надо не забыть про пуши. Без них никуда.
> 
> Игорь Солкин, [26.06.19 16:23]
> Там довольно просто. В пуш-сервисе регается приложение, выдаётся ID, сервер его знает.
Затем, когда клиент коннектится к серверу, сообщается свой push token. Сервер сохраняет его в сессии пользователя и когда клиент не на месте, сервер шлёт в пуш-сервис событие с ID и push token.
> 
> Max Musatov, [26.06.19 16:27]
> Ну то есть задача протокола в любом случае сводится просто к тому, чтобы передать на сервер этот push token?
> 
> Игорь Солкин, [26.06.19 16:27]
> Со стороны API да.
> 
> Игорь Солкин, [26.06.19 16:27]
> Нужна просто отдельная ручка, где клиент может передать свой push token.
> 
> Max Musatov, [26.06.19 16:27]
> Ну ок, впихнём куда-нибудь, остальное можно и потом обдумать.

## Layer 1: подключение и регистрация `EXPERIMENTAL`

В слой 1 входят только эти возможности. Теоретически сервер может реализовывать только этот слой и использоваться как сервер аутентификации (хотя мы с трудом представляем себе юзкейс).

TODO: отказ в авторизации (блокировка аккаунта, технические работы, etc)

| Тип пакета            | Поля |
| --------------------- | ---- |
| HELLO                 | protocol-layer `uint64`     |
| &gt;                  | highest-supported-layer `uint64`<br />servername `string`<br />federated `bool`<br />supported-auth-methods `array[string]`<br />supported-register-methods `array[string]`
| AUTH-PLAIN            | login `string`<br />password `string`
| &gt;                  | sessid `string`
| REGISTER-PLAIN        | login `string`<br />password `string`
| REGISTER-INSTRUCTIONS |
| &gt;                  | text `string`<br />(optional) url `string`

### Приветствие

TODO: здесь непонятно, что делать, если у HELLO слишком большой layer

После подключения клиент ДОЛЖЕН отправить серверу пакет с приветствием:

```
<< HELLO
   highest-supported-layer=1
>> 200
   highest-supported-layer=6
   servername=m1kc.ru
   federated=false
   supported-auth-methods=[AUTH-PLAIN]
   supported-register-methods=[REGISTER-PLAIN, REGISTER-INSTRUCTIONS]
```

И сервер, и клиент переключаются на использование наименьшего layer из поддерживаемых обоими. Если layer сервера выше, он ДОЛЖЕН отправлять только те пакеты, которые поддерживаются клиентом, или разорвать соединение. Если layer клиента выше, клиент ДОЛЖЕН отправлять только те пакеты, которые поддерживаются сервером, или разорвать соединение.

Сервер ДОЛЖЕН предоставлять хотя бы один метод аутентификации и один метод регистрации (приватные сервера могут использовать `REGISTER-INSTRUCTIONS`). Клиент выбирает те методы, который ему больше подходят. Методы МОГУТ не предусматривать использование паролей (заменяя их, к примеру, на приватные ключи или 2FA).

### Обычная аутентификация (AUTH-PLAIN)

Пароль - нешифрованный текст в кодировке UTF-8, преобразованный в BASE64.

```
<< AUTH-PLAIN
   login=Vasya
   password=540345095834ncv095==
>> 200
   sessid=1712d9f9ddc9a5b23707ebbea4d45255
>> 403
```

### Обычная регистрация (REGISTER-PLAIN)

Пароль - нешифрованный текст в кодировке UTF-8, преобразованный в BASE64.

```
<< REGISTER-PLAIN login=Vasya password=540345095834ncv095==
>> 200
>> 400 reason=why
>> 403 reason=why
```

### Получение инструкций по регистрации через иной механизм (REGISTER-INSTRUCTIONS)

```
<< REGISTER-INSTRUCTIONS
>> 200
   text='Подайте заявление в электронном виде'
   url='https://example.com/register'
```

> Нужно определить, как именно это будет отображаться в UI. А то я уже вижу, как сюда пишут "на вашем телефоне обнаружен вирус, срочно скачайте антивирус по ссылке".

## Layer 2: список контактов `EXPERIMENTAL`

Модели:

| Название             | Поля |
| -------------------- | ---- |
| Contact              | contact_id `string`<br />name `string`<br />group `array[string]`
| ContactWithLastSeen  | contact `Contact`<br />last-seen `timestamp`

Пакеты:

| Тип пакета           | Поля |
| -------------------- | ---- |
| CONTACTS-GET         |
| &gt;                 | data `array[ContactWithLastSeen]`
| CONTACTS-ADD         | `Contact`
| CONTACTS-CHANGE      | `Contact`
| CONTACTS-DELETE      | contact_id `string`
| &gt; CONTACT-ADDED   | `Contact`
| &gt; CONTACT-CHANGED | `Contact`
| &gt; CONTACT-DELETED | contact_id `string`

### Получение списка контактов

После подключения клиент МОЖЕТ запросить список контактов:

```
<< CONTACTS-GET
>> 200
{
    "data": [
        {
            "contact": {
                "group": ["Friends", "Best friends"],
                "id": "alice@dev.test",
                "name": "Alice"
            },
            "last-seen": "2000-09-09T14:22:31+0300"
        },
        ...
    ]
}
```

Массив group описывает вложенные группы (в этом примере Алиса находится в группе Best friends, которая в свою очередь находится в группе Friends). Если контакт не находится ни в одной группе, массив будет пустым.

### Управление контактами

```
<< CONTACTS-ADD name=m1kc id=m1kc@m1kc.ru group=[]
>> 200

<< CONTACTS-CHANGE id=m1kc@m1kc.ru name=MIKUSO group=[]
>> 200

<< CONTACTS-DELETE id=m1kc@m1kc.ru
>> 200
```

### Уведомления об изменении контактов на сервере

```
>> CONTACT-CREATED
    {
        "contact": {
            "group": ["Friends", "Best friends"],
            "id": "alice@dev.test",
            "name": "Alice"
        },
        "last-seen": "2000-09-09T14:22:31+0300"
    }

>> CONTACT-UPDATED
    {
        "contact": {
            "group": ["Friends", "Best friends"],
            "id": "alice@dev.test",
            "name": "Alice"
        },
        "last-seen": "2000-09-09T14:22:31+0300"
    }
    
>> CONTACT-DELETED
   id=m1kc@klfd.com
```


## Layer 3: Отправка сообщений, работа с историей `EXPERIMENTAL`

Модели:

| Название             | Поля |
| -------------------- | ---- |
| Chat                 | chat_id `string`<br />unread_messages `uint64`<br />last_message_id `uint64`<br />read_till_id `uint64`
| ChatMessage          | message_id `uint64`<br />previous_message_id `uint64`<br />cookie `*string`<br />time `timestamp`<br />chat_id `string`<br />from `string`<br />text `string`
| OutgoingMessage      | chat_id `string`<br />text `string`<br />cookie `string`

Пакеты:

| Тип пакета           | Поля |
| -------------------- | ---- |
| CHATS-GET            |
| &gt;                 | data `array[Chat]`
| CHAT-HISTORY         | id_till `uint64`<br />id_from `uint64`<br />count `uint64`<br />date_from `string YYYY-MM-DD`
| &gt;                 | data `array[ChatMessage]`
| CHATS-UPDATED        | `Chat`
| MESSAGE-SEND         | `OutgoingMessage`
| &gt;                 | cookie `string`<br />message_id `uint64`<br />time `timestamp`
| READ-CHAT            | message_id `uint64`
| CHAT-READ-TILL       | message_id `uint64`<br />chat_id `string`<br />user `string`
| MESSAGE-RECEIVE      | `ChatMessage`
| MESSAGE-READ-ACK     | message_id `uint64`
| HISTORY-REWIND       | message_id_gt `uint64`
| &gt;                 | data `array[ChatMessage]`

Список чатов хранится на сервере. Там же хранится пометка, до какого сообщения дочитала каждая из сторон чата. После авторизации клиент МОЖЕТ запросить список чатов:

```
<< CHATS-GET
>> 200
   [{
       id: 'm1kc@msim.example.com',
       unread_messages: 4,
       last_message_id: 25673493842,
       delivered_till_id: 25673493820,
       read_till_id: 25673493820,
   },
   ...
   ]
```

В качестве id чата используется id контакта. Групповым чатам (не определены в этой спецификации) также назначаются id вида `something@server.name`.

Если клиент использует иконки для отображения статуса сообщения, ему СЛЕДУЕТ пользоваться следующей логикой:

| Статус                 | Пример UI |
| ---------------------- | ---------:|
| Отправляется на сервер | Привет, давай встретимся завтра часа в три? Или в четыре, как удобнее.<br />:arrow_double_up: **18:00**
| Доставлено на сервер, но не прочитано | Привет, давай встретимся завтра часа в три? Или в четыре, как удобнее.<br />:envelope: **18:00**
| Прочитано (нет иконки) | Привет, давай встретимся завтра часа в три? Или в четыре, как удобнее.<br />**18:00**

Этот запрос я бы не стал делать, он идёт сильно вразрез остальной работе с историей.

Да понятно, но нужен какой-то более быстрый способ обновить чаты с прошлого раза. Типа, если у тебя в 35 чатов пришло одно сообщение, с обычной синхронизацией надо будет 35 раз гонять пакеты туда-сюда. Не гуд.

> Также клиент МОЖЕТ запросить все непрочитанные сообщения из всех чатов:
> 
> ```
> << CHATS-GET-UNREAD-MESSAGES
> >> 200
>    [{
>        chat_id: 'm1kc@msim.example.com',
>        message_id: 25673493842,
>        previous_message_id: 25673493841,
>        text: 'Привет',
>    },
>    ...
>    ]
> ```
> 
> TODO: отправлять несколькими пакетами?
> 
> Клиенту СЛЕДУЕТ отказаться от использования этой возможности, если общее число непрочитанных велико (скажем, больше 200).

Каждое сообщение содержит в себе ID предыдущего. С их помощью клиент может проверить целостность своей локальной истории сообщений и дозапросить недостающие.

Клиент имеет возможность запросить отрывок истории переписки:

```
<< CHAT-HISTORY
   chat_id=m1kc@example.com
   id_from=4908390834209
   id_till=4908390834215
<< 200
   [{
       message_id=4908390834210
       previous_message_id=4908390834209
       time=1558648325
       from=m1kc@example.com
       text='Это точно'
   },
   ...
   ]
```

Возможные комбинации параметров:
* `id_from`, `id_till` (сообщения между двумя заданными)
* `id_from`, `id_till`, `count` (сообщения между двумя заданными, но не более N штук)
* `id_from`, `count` (N сообщений после заданного)
* `id_till`, `count` (N сообщений до заданного)
* `date_from`, `count` (N первых сообщений от заданной даты, YYYY-MM-DD)

В качестве ID могут использоваться краевые значения для диалога:
`0` - начало диалога
`-1` - конец диалога

### TODO: дозапрос всей истории, начиная с message id

### Отправка сообщения

```
<< MESSAGE-SEND
   chat_id=m1kc@example.com
   text='Whatever!'
   cookie='j32904328c0348c209832nc0jsdf'
>> 200
   message_id=4908390834209
   time=1558648325
```

Если чата не существует, он будет создан. Если сообщение с таким cookie уже было, сервер отвечает кодом 201 и возвращает его id (вообще не проверяя, такой же текст или нет).

### Получение, уведомление о прочтении

```
>> MESSAGE-RECEIVE
   chat_id=solkin@example.com
   from=m1kc@example.com
   text='Whatever!'
   message_id=4908390834209
   previous_message_id=4908390834208
   time=1558648325

<< MESSAGE-RECEIVE-ACK
   chat_id=solkin@example.com
   message_id=4908390834209
>> 200

<< MESSAGE-READ-ACK
   chat_id=solkin@example.com
   message_id=4908390834209
>> 200
```

Прочитанными помечаются заданное сообщение и все, что до него. Можно подтвердить не все непрочитанные, а только часть.

Другой стороне тоже отправляется уведомление о прочтении:

```
>> CHATS-UPDATED
   [{
       id: 'm1kc@example.com',
       unread_messages: 4,
       last_message_id: 25673493842,
       delivered_till_id: 25673493820,
       read_till_id: 25673493820,
   },
   ...
   ]
```

Заметим, что для отправки и получения сообщений клиенту в общем случае не нужно знать список контактов, чатов и отправленных ранее сообщений, что значительно упрощает использование mSIM во встраиваемых устройствах, датчиках и консольных клиентах.

-------------------------------

-------------------------------

-------------------------------

## Основные возможности

### Сообщения с аттачем

Под `blob` подразумевается бинарный контент, приложенный к сообщению. Это может быть стикер, небольшой файл изображения или крошечный документ. Ограничение может быть предусмотрено в несколько килобайт. В любом случае, сервер должен обрывать запросы больше определённого размера, пакет сообщения не исключение.
```
<< MESSAGE to=m1kc@whatever.com text=HJDJKFDSJKsjfjoifuwhiufe blob=<data>
>> 200 id=789387923
>> 400
```

Либо можно сделать отдельный тип сообщений blob, вроде так почётче. Тоже думал над таким форматом. Можно и так сделать.
```
<< MESSAGE to=m1kc@whatever.com type=text text=<data>
<< MESSAGE to=m1kc@whatever.com type=blob blob=<data>
```

### Уведомление о наборе текста

```
>> TYPING-STARTED from=solkin@whatever.com
>> TYPING-END from=solkin@whatever.com
```

### Presence

```
>> UPDATE-LAST-SEEN id=Vasya at=2018-09-09T14:22:31+0300
```

## Управление контактами


### Контакт изменился на сервере

...Может, вообще весь список заново отправлять... Накладно будет. Зато действительно можно присылать то, что поменялось и упростить работу last-seen. Интересно. Но пока не могу понять, нравится мне такой подход или нет. Клиенту надо будет ещё проверять, поменялось ли имя (и надо ли теперь лезть в sqlite и обновлять его). Обработчик этого пакета станет слишком умным. М-м...
По опыту Мандарина могу сказать, что last-seen и изменение списка всё равно сводилось к одной операции. Может, это только у тебя так? Я пытаюсь представить себе это - наверное, всё-таки это были бы разные вещи, если я реально храню историю с привязкой к контактам и их имена тоже храню.
Так ведь клиенту и так и так надо обновить одну и ту же сущность - контакт. И не важно, какое поле у него поменялось, имя и время. Клиент получается максимально тонким.
Но ведь last-seen он обычно хранится в памяти, а имя в каком-нибудь sqlite. Разница. Нет. Всё хранися рядом в одной записи базы. А зачем ты хранишь в базе last seen? И блин, это ж всё время в базу лазить.
Поход в базу дешёвый. Это одно. Но главное, что клиент ты можешь убить 100 раз в минуту и клиенту не нужно постоянно идти на сервер и актуализировать информацию по контактам.
А, блин, да, это ж андроид. Понял, почему. Но на десктопах не так делают.
iOS то же самое. На десктопе можно делать как угодно, сути это всё равно не меняет. Или, например, взять тот же Web. Там вообще ничего хранить не надо, но сущность обновляется без задней мысли. Контакт поменялся? Обновляем.
Ладно, оставим пока оба типа, потом выкинем отдельный, если не передумаем. Ок см. дальше

```
>> CONTACT-UPDATED
    [
    ...id=m1kc@klfd.com
    ...last-seen=2018-09-09T14:22:31+0300
    ]
```
```
>> CONTACT-UPDATED
    [
    ...id=m1kc@klfd.com
    ...note=Vacationing
    ]
```
```
>> CONTACT-UPDATED
    [
    ...id=m1kc@klfd.com
    ...name=m1kc
    ]
```


...Так. А что, если просто добавить поле group в контакт? Хочешь удалить группу - ну удали все контакты в ней.
Так как раз в XMPP сделано. Бодрое решение. Но, вероятно, группы вообще должны быть опциональны. Типа, не хочешь указывать группу - не надо. Это правильно. Ещё можно сделать вложенные группы для самых упоротых, типа `group1.group2` и на самом деле group2 вложена в group1. Можно и так. Это уже на уровень клиента выходит тогда. Можно через `/` ещё.

Кстати, можно сделать некую сущность `note` у контакта. Для тех случаев, когда контакту нужна пометка. Типа текстового статуса. Полезно бывает, например, в корпоротивном использовании, когда уходишь в отпуск. Согласен

### Профили

TBD

А давай её прям одним из полей контакта сделаем?
Имеешь в виду профиля?

`CONTACTS-UPDATE id=m1kc@m1kc.ru name=m1kc note=Whatever Vacation`
А, так я имел в виду, что пользователь сам заполняет себе заметку. 
А, профили... О них я не думал. Они нужны?
По хорошему, было бы неплохо иметь имя контакта, чтобы каждому его не задавать вручную. При желании, конечно, можно изменить.
Ладно, добавим потом. Но это явно не для MVP, как мне кажется.
Может быть. А так, `note` конечно является полем контакта в списке, как и `last-seen`. Тоже заполяется не самим владельцем списка контактов. В общем, его можно потом.
```
<< PROFILE-UPDATE name=Superuser
>> PROFILE-UPDATE-FAILED reason=why
>> PROFILE-UPDATE-OK
```
```
<< PROFILE-UPDATE name=Megauser, note=Vacationing
>> PROFILE-UPDATE-FAILED reason=why
>> PROFILE-UPDATE-OK
```


### Отправка файлов

Всё же я бы сделал возможность кратковременного хранения файлов на сервере. Либо даже только такой способ и только для мелких файлов. Для начала можно вообще только изображения рассмотреть.
```
Вася:
<< SEND-FILE-PROXY filename=virus.exe size=128000
>> 200

Сервер - Пете:
>> SEND-FILE-PROXY-REQUEST filename=virus.exe size=128000 transfer-id=123
<< SEND-FILE-PROXY-ACCEPT transfer-id=123
<< SEND-FILE-PROXY-REJECT transfer-id=123

Сервер - Васе:
>> SEND-FILE-PROXY-OK connect=filetransfer.com port=5555 transfer-id=123
>> SEND-FILE-PROXY-REJECTED transfer-id=123
```

Протокол передачи файлов на прокси:

TBD

Далее клиент подключается на другой порт 3215 и передаёт файл в аналогичном виде:

## Федерация

TBD

Серверу нужно, наверное, иметь возможность запретить внешние взаимодействия? Хотя при этом получается рак-отшельник, который ни с кем другим не общается.

Конечно. В этом случае он просто отвечает, что федерация not implemented.

Конечно, неплохо бы об этом ещё заранее как-то сообщить, типа как капсы при подключении слать. Ну или просто federated=false.
Думаю, проще всего реально через `not supported` И там уже не нужно гадать, почему он не поддерживает. Просто не поддерживает.
Ну можно совместить: при подключении предупреждать, а при попытке, например, добавить контакт с другого сервера - фейлить. А если сервер контакта не поддерживает федерацию? Тогда... я думаю, на первом этапе можно вообще не проверять контакты на других серверах и позволять добавлять любые. Потом сделать какой-то специальный пакет, чтобы спросить, есть такая учётка или нет.
При изменении информации у пользователя надо будет проходить по списку и слать изменения не только себе на сервер, но если контакт внешний, отправлять запросы другому серверу через федерацию.
Предлагаю это делать сильно позже. 
Я думаю, обновления ни профилей, ни last seen по умолчанию на другие сервера слать не нужно. Потом сделаем какой-то механизм подписки на обновления. Если попросили - шлю.
По идее, должно быть единообразно с сообщениями. А описанный мехнизм ниже должен лежать в транспортном уровне. Типа, хочу отправить пакет твоему клиенту. Подключаюсь, проходит хэндшейк и пакет уходит.

Сервер подключается к другому серверу  
Говорит: я solkin.ru, хочу подключиться к m1kc.ru  
Если я m1kc.ru, то говорю: вот тебе challenge  
Ты подписываешь challenge своим закрытым ключом  
Я получаю твой открытый ключ из DNS-записи и убеждаюсь, что ты и правда solkin.ru
Далее происходит отправка пакета, аналогично отправке пакета локальному пользователю. Сторонний сервер проксирует данные без дополнительной обработки. Либо проверяет исключительно с целью соответствия, хотя это уже из области безопасности. Ну да. Наверное, просто добавим в пакет поле from, которое разрешено заполнять только серверам. И оно как раз на этапе хэндшейка будет выступать как необходимая информация. Можно так.


## Работа с историей (старый черновик)

*Список чатов хранится на сервере. Там же хранится, какие сообщения были прочитаны, а какие ещё нет.*

*При подключении клиент запрашивает список чатов, последние N сообщений и сколько непрочитанных в каждом.*

*Зайдя в чат, клиент может попросить что-то вроде "у меня самое верхнее сообщение id 123, дай мне ещё 50 сообщений выше него. Но если дойдёшь до id 111, дальше не отдавай, у меня они тоже уже есть".*

*Ещё можно попросить N сообщений с начала истории, N сообщений с определённой даты. Ещё можно сделать поиск. Ещё можно попросить удалить чат для обеих сторон.*

У всех сообщений в истории есть уникальный монотонно-возрастающий ID.
Вся история в чатах представляет из себя цепочку сообщений, то есть каждое сообщение имеет свой ID и ID предыдущего сообщения.
Первое сообщение в чате получает некоторый уникальный ID, а ID предыдущего считается `0`.
Далее, при сохранении сообщения ему присваивается личный ID и выставляется ID предудщего.
Сделано это с той целью, чтобы клиент всегда мог актуализировать состояние чата, даже если в нём при определённых обстоятельствах образовалось несколько "дырок".
Пример образования дырок и их закрытия:
1. Клиент первый раз подключился и получил последнее сообщение в чате.
2. Клиент на некоторое время отключился и общался на другом устройстве.
3. Клиент снова подулючился и вновь получил последние сообщения в чатах. Получается два разрозненных сообщения в истории.
4. Пользователь открывает диалог. Клиент видит нестыковки `id` и `prev_id` между сообщениями, запрашивает фрагмет истории между ними, сервер его присылает.

### Открытие/закрытие чата
Фложок чата является атрибутом контакта. При открытии чата клиент отправляет на сервер событие об изменении контакта. Сервер сохраняет модификацию контакта и выставляет ему флажок `dialog=true`

```
<< CONTACTS-CHANGE id=m1kc@m1kc.ru dialog=true
>> 200
>> 400 reason=why
```

```
>> CONTACT-UPDATED
    [
    ...id=m1kc@klfd.com
    ...dialog=true
    ]
```

### Входящее сообщение
При подключении сервер присылает клиенту список контактов. Для контактов с открытыми диалогами приходит также атрибут `last_message`.

```
>> CONTACT-UPDATED
    [
    ...id=m1kc@klfd.com
    ...dialog=true
    ...last_message=
        [
        ...prev_id=122
        ...id=123
        ...direction=incoming
        ...text=Hello, mSIM!
        ]
    ]
    ]
```

### Получение истории
Клиент имеет возможность запросить отрывок истории переписки.
Возможные комбинации параметров:
`from_id`, `till_id`
`from_id`, `count`
`till_id`, `count`

В качестве ID могут использоваться краевые значения для диалога:
`0` - начало диалога
`-1` - конец диалога

Клиент получает от сервера массив сообщений из указанной дыры в истории.
```
<< HISTORY-REQUEST id=m1kc@whatever.com, from=[123, 125]
>> HISTORY-REQUEST
[id=123 from=m1kc@whatever.com text="Hello, World!"], 
[id=124 from=m1kc@whatever.com text="Hello again!"], 
[id=125 from=m1kc@whatever.com text="Hello!"]
```

### Исходящее сообщение
Клиент отправляет сообщения со случайным `cookie`. Сервер сразу складывает его в очередь и отвечает, что всё хорошо.
```
<< MESSAGE-SEND to=m1kc@whatever.com text=Hello! cookie=j52n45d2beir39
>> 200
```
Затем приходит обновление диалога, в котором присутствует уже вся необходимая информация.
```
>> CONTACT-UPDATED
    [
    ...id=m1kc@klfd.com
    ...last_message=
        [
        ...prev_id=122
        ...id=123
        ...cookie=j52n45d2beir39
        ...time=2574389057
        ...direction=outgoing
        ]
    ]
    ]
```

### Доставка и прочтение
Клиент по мере получения и прочтения сообщения отправляет соответствующие запросы:

```
<< DIALOG-UPDATE
    [
    ...id=m1kc@klfd.com
    ...delivered_till=123
    ...read_till=122
    ]
```

Сервер присылает собеседнику пакет об обновлении информации о контакте:
```
>> CONTACT-UPDATED
    [
    ...id=m1kc@klfd.com
    ...delivered_till=123
    ...read_till=122
    ]
```
